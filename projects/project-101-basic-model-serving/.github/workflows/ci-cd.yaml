# CI/CD Pipeline for ML Model Serving
# This GitHub Actions workflow automates:
# - Code linting and formatting checks
# - Running tests
# - Building Docker images
# - Pushing to container registry
# - Deploying to Kubernetes (optional)

name: CI/CD Pipeline

# ==============================================================================
# TODO: Define Workflow Triggers
# ==============================================================================
# Specify when this workflow should run

on:
  # Trigger on push to main branch
  push:
    branches:
      - main
      - develop
    # Only run if these paths change
    paths:
      - 'src/**'
      - 'tests/**'
      - 'requirements.txt'
      - 'Dockerfile'
      - '.github/workflows/**'

  # Trigger on pull requests
  pull_request:
    branches:
      - main
      - develop

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy to'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production

# ==============================================================================
# TODO: Define Environment Variables
# ==============================================================================
# Set global variables for the workflow

env:
  PYTHON_VERSION: '3.11'
  DOCKER_IMAGE_NAME: ml-model-serving
  DOCKER_REGISTRY: ghcr.io  # GitHub Container Registry
  # Or use: docker.io for Docker Hub, or your own registry

# ==============================================================================
# TODO: Define Jobs
# ==============================================================================

jobs:
  # ============================================================================
  # Job 1: Code Quality Checks
  # ============================================================================
  code-quality:
    name: Code Quality & Linting
    runs-on: ubuntu-latest

    steps:
      # TODO: Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # TODO: Set up Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'  # Cache pip dependencies

      # TODO: Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black isort mypy
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi

      # TODO: Run Black (code formatter check)
      - name: Check code formatting with Black
        run: |
          black --check src/ tests/
          # Use --diff to see what would change
          # Remove --check to auto-format

      # TODO: Run isort (import sorting check)
      - name: Check import sorting with isort
        run: |
          isort --check-only src/ tests/
          # Remove --check-only to auto-sort

      # TODO: Run flake8 (linting)
      - name: Lint with flake8
        run: |
          # Stop the build if there are Python syntax errors or undefined names
          flake8 src/ tests/ --count --select=E9,F63,F7,F82 --show-source --statistics

          # Treat all errors as warnings
          flake8 src/ tests/ --count --max-complexity=10 --max-line-length=100 --statistics
        continue-on-error: true  # Don't fail build on warnings

      # TODO: Run mypy (type checking)
      - name: Type check with mypy
        run: |
          mypy src/ --ignore-missing-imports
        continue-on-error: true  # Optional for learning project

  # ============================================================================
  # Job 2: Run Tests
  # ============================================================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: code-quality  # Run after code quality checks

    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
        # Test on multiple Python versions

    steps:
      # TODO: Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # TODO: Set up Python
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      # TODO: Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # Install CPU-only PyTorch for faster CI
          pip install torch torchvision --index-url https://download.pytorch.org/whl/cpu
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio

      # TODO: Run tests with coverage
      - name: Run tests
        run: |
          pytest tests/ -v --cov=src --cov-report=xml --cov-report=term
          # -v: verbose output
          # --cov: measure code coverage
          # --cov-report: generate coverage report

      # TODO: Upload coverage to Codecov (optional)
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          fail_ci_if_error: false
        if: matrix.python-version == '3.11'  # Only upload for one Python version

  # ============================================================================
  # Job 3: Build Docker Image
  # ============================================================================
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test  # Run after tests pass
    if: github.event_name == 'push'  # Only on push, not PR

    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}

    steps:
      # TODO: Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # TODO: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        # Buildx enables advanced Docker features

      # TODO: Log in to Container Registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          # For Docker Hub, use:
          # username: ${{ secrets.DOCKERHUB_USERNAME }}
          # password: ${{ secrets.DOCKERHUB_TOKEN }}

      # TODO: Extract metadata (tags, labels)
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}
          # Generates tags like:
          # - main
          # - pr-123
          # - 1.0.0
          # - 1.0
          # - sha-abc123
          # - latest (only on main branch)

      # TODO: Build and push Docker image
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha  # GitHub Actions cache
          cache-to: type=gha,mode=max
          # Cache layers for faster builds

      # TODO: Run security scan (Trivy)
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      # TODO: Upload Trivy results to GitHub Security tab
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        if: always()

  # ============================================================================
  # Job 4: Deploy to Kubernetes (Optional)
  # ============================================================================
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    # Only deploy on push to main branch

    environment:
      name: ${{ inputs.deploy_environment || 'development' }}
      url: https://${{ steps.deploy.outputs.app_url }}

    steps:
      # TODO: Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # TODO: Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      # TODO: Configure kubectl with kubeconfig
      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        # Store your kubeconfig in GitHub Secrets as base64:
        # cat kubeconfig.yaml | base64 | pbcopy

      # TODO: Update deployment with new image
      - name: Deploy to Kubernetes
        id: deploy
        run: |
          # Update image in deployment
          kubectl set image deployment/ml-model-serving-deployment \
            ml-api=${{ needs.build.outputs.image_tag }} \
            -n default

          # Wait for rollout to complete
          kubectl rollout status deployment/ml-model-serving-deployment -n default

          # Get app URL
          APP_URL=$(kubectl get svc ml-model-serving-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT

      # TODO: Run smoke tests
      - name: Run smoke tests
        run: |
          SERVICE_URL="http://$(kubectl get svc ml-model-serving-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"

          # Test health endpoint
          curl -f $SERVICE_URL/health || exit 1

          # Test basic prediction
          # curl -X POST $SERVICE_URL/predict -F "file=@test_image.jpg" || exit 1

      # TODO: Rollback on failure
      - name: Rollback deployment on failure
        if: failure()
        run: |
          kubectl rollout undo deployment/ml-model-serving-deployment -n default

  # ============================================================================
  # Job 5: Notify (Optional)
  # ============================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()  # Run even if previous jobs fail

    steps:
      # TODO: Send Slack notification
      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Deployment ${{ job.status }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Deployment *${{ job.status }}* for *${{ github.repository }}*\nBranch: `${{ github.ref_name }}`\nCommit: `${{ github.sha }}`"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()

---
# ==============================================================================
# Setup Instructions
# ==============================================================================
# To use this workflow:
#
# 1. Add secrets to GitHub repository:
#    Settings → Secrets and variables → Actions → New repository secret
#
#    Required secrets:
#    - GITHUB_TOKEN (automatically provided)
#    - KUBECONFIG (base64-encoded kubeconfig file)
#    - SLACK_WEBHOOK_URL (optional, for notifications)
#
#    For Docker Hub:
#    - DOCKERHUB_USERNAME
#    - DOCKERHUB_TOKEN
#
# 2. Enable GitHub Container Registry:
#    Settings → Packages → Enable improved container support
#
# 3. Configure environments (optional):
#    Settings → Environments → New environment
#    - development
#    - staging
#    - production
#
# 4. Push code to trigger workflow:
#    git add .
#    git commit -m "Add CI/CD pipeline"
#    git push origin main
#
# ==============================================================================

---
# ==============================================================================
# Alternative: Simplified CI/CD for Learning
# ==============================================================================
# Simpler version focusing on tests and Docker build:
#
# name: Simple CI/CD
#
# on:
#   push:
#     branches: [main]
#   pull_request:
#     branches: [main]
#
# jobs:
#   test:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       - uses: actions/setup-python@v5
#         with:
#           python-version: '3.11'
#       - run: pip install -r requirements.txt pytest
#       - run: pytest tests/
#
#   build:
#     needs: test
#     runs-on: ubuntu-latest
#     if: github.event_name == 'push'
#     steps:
#       - uses: actions/checkout@v4
#       - uses: docker/build-push-action@v5
#         with:
#           context: .
#           push: false
#           tags: ml-model-serving:latest
#
# ==============================================================================

---
# ==============================================================================
# Monitoring Workflows
# ==============================================================================
# View workflow runs:
# - Go to repository → Actions tab
# - See all workflow runs, their status, and logs
#
# Workflow status badge (add to README.md):
# ![CI/CD](https://github.com/username/repo/workflows/CI%2FCD%20Pipeline/badge.svg)
#
# ==============================================================================

---
# ==============================================================================
# Best Practices
# ==============================================================================
# 1. Use caching for dependencies (pip, Docker layers)
# 2. Run tests before building images
# 3. Use matrix strategy to test multiple Python versions
# 4. Tag images with commit SHA for traceability
# 5. Run security scans on Docker images
# 6. Use environments for production deployments
# 7. Implement rollback on deployment failure
# 8. Add smoke tests after deployment
# 9. Send notifications on failures
# 10. Keep secrets in GitHub Secrets, never in code
# ==============================================================================
